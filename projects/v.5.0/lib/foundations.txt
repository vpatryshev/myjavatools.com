<h2>Introduction</h2>

Java already has a rich library that deals with abstract types like Set, List (aka tuple), Map; and it seems like there is not much need to add more. Nevertheless, for years I've been adding classes and methods to my private library. Then Java generics went out of the closet - and I have discovered that with generics one can make miracles... I mean, develop and start using really generic and mathematically sound classes. So I refactored my library to generics, and here it is. Below I will use Java features and classes from version 5.

<lj-cut>

<h2>Collections Revisited</h2>

Users, both beginners and those that are too busy to upgrade, often mix interfaces and abstract classes from Collections framework with their concrete implementations that combine abstract ideas with specific strategies: for instance, List has two implementation strategies, LinkedList and ArrayList. The fact that it is linked or array-ed, has nothing to do with its core functionality; implementations can vary, and what's important from the client point of view is that they are all Lists - and another thing is important: performance; but we definitely need to separate performance concerns from presentation.

So, having this in mind, here's the current hierarchy of fundamental classes in Java:

<b>Iterable</b> - an abstraction of an enumerable entity; all it has is iterator() that returns an Iterator to scan through components. It does not mean that elements are in a certain order - there is a big conceptual difference between having a certain order and an existence of an order in which elements could be listed, with none of such orders being an attribute of the entity. 

We cannot know the number of elements in an Iterable; in principle, we could define <code>boolean isEmpty()</code> as <code>{ return iterator().hasNext(); }</code>, but in many cases this definition can be costly. For instance, the Iterable can be a resource on the internet, each next() returning a byte - checking its emptiness would involve opening a connection. It would be interesting, on the other hand, to to have Iterable File and URL readers.

It would be interesting to find out whether there is an analog of Iterable in mathematics.

<b>Collection</b> is an Iterable that has knows its size, can have methods for adding and deleting elements, check whether an element is a member of the collection, and which can be converted to an array - using the fact that its size is known in advance. No exact match in mathematics; a bag, or a multiset, can be considered as a model if we could take Collections out of the hierarchy and treat them as a separate entity.

<b>List</b> is a Collection where elements have a linear order. List is known as Sequence in IDL, and as tuple in mathematics. It has the first element, the last element, and can have methods for inserting and deleting elements. Two lists are declared equal if they have the same size and all its consecutive elements are equal.

<b>Set</b> is a Collection where elements do not repeat. Sets are modeled after sets in Set Theory: two sets are equal if they contain the same elements (Extensionality Axiom). Sets do not have any additional operations; the only additional method equals() makes them distinct from other possible types of collections.

<b>SortedSet</b> is a special kind of Set that is linearly ordered. SortedSet in Java extends Set - which basically means that order is used only for storing data. While two SortedSets that have the same elements but a different comparator are equal(), it is impossible to addAll() from one SortedSet to another unless their comparators are equal().

<b>Map</b> represents a function defined on a set and taking values of a certain type. Technically speaking, a Map is fully determined by a Set of its key-value pairs. A Map can return a value for a specified key, the whole set of its keys, keySet() and a collection of its values; this collection is neither a set (can have repeating values) nor a List (order does not matter). A Map can have methods for adding and removing key-value pairs.

<h2>Foundation Classes</h2>

The classes reviewed above were enough for Java Before Tiger. Now, with generics, more can be offered to effectively and efficiently write Java code using collections and avoiding 'for' loops and plain arrays, two legacy constructs that we inherited from Fortran and C. Below I'll talk about two foundation classes and three utility classes with a bunch of static methods for dealing with collections. The most fundamental notion in mathematics is a...

<b>Function</b>

In Java, we can define interface <code>Function&lt;X,Y></code>: it has just one method, <code>Y apply(X x)</code>. An objectivised function can be handled now as an entity: we can compose and invert functions, we can apply them to collections, we can instantiate functions from other objects. 

There is a big difference between a Function and a Map: a Function is defined on a type, and a Map is defined on a Set. If we have a <code>Map m</code>, we can define a <code>Function function(m)</code>: it will return <code>m.get(x)</code> for any <code>X x</code>, but to get a Map from a Function, we will need a Set of keys. Also, <code>equals()</code> is defined for Maps, but for Functions it is very impractical to define equals(): we would need to scan through the whole range of type values to check whether two Functions are equal.

Actually, in the package <code>com.myjavatools.lib.foundation</code>, Function.java is not an interface, but an abstract class with one abstract method, <code>apply()</code>. Other methods provide the functionality I wrote above: function factory <code>static Function&lt;X,Y> function(Map&lt;X,Y> map)</code>; <code>Map&lt;X,Y> toMap(Set&lt;X> keys)</code> - a Map view of the function, with Set&lt;X> keys as keys; <code>Map&lt;X,Y> toMap(Collection&lt;X> keys)</code>. 

<code>List&lt;Y> apply(List&lt;X>) </code> - this one returns a List view of function values on the provided list. Notice, it is a view, and the user will want to use a copy constructor to avoid recalculating function values every time an element is retrieved; on the other hand, the user is free to deal with this List view, and avoid creating new objects. Saving memory does not seem to be a big issue these days, but memory management, creation and disposal of objects may take too many resources. Similar methods <code>Iterable&lt;Y> apply(Iterable&lt;X>)</code> and <code>Iterator&lt;Y> apply(Iterator&lt;X>)</code> apply a Function to an Iterable and an Iterator.

Function has two methods for composition, one is static, to apply this function after the parameter function: <code>f.compose(g)</code> is a function that returns <code>f.apply(g.apply(arg))</code>; another one is a static method, which looks closer to classical mathematics: <br><code> &lt;X,Y,Z> Function &lt;X,Z> compose(Function&lt;X,Y> f, Function&lt;Y,Z> g)</code>

<b>Filter</b>

A Filter, a.k.a. predicate, is a Function&lt;X,Boolean>, that is, a function that returns logical values. One could argue regarding overusing "boolean", but Java does not give much of a choice. Filter has an alias for <code>apply()</code>: <code>accept()</code>. Tho methods in this class do the actual data filtration, the same way grep function does: <code>Iterator&lt;T> filter(Iterator&lt;T>)</code> and  <code>Iterable&lt;T> filter(Iterable&lt;T>)</code>. The latter is, of course, a view Iterable, not a new array or something; the user is free to create a "hard copy" of the filtered Iterable, when necessary.

<b>Pair</b>

This is an implementation of Map.Entry&lt;X,Y> interface, only <code>key</code> and <code>value</code> are named <code>left</code> and <code>right</code> components; with the addition of <code>swap()</code> method. Theoretically, Pair&lt;X,Y> could serve as an alternative to List&lt;X> implementation of the notion of tuple from mathematics.

<h2>Utility Foundation Classes</h2>

<b>Iterators</b>

This class contains several static <code>cat()</code> methods that concatenate collections. Namely, <code>cat(Arrays.asList("abc", "def"), Arrays.asList("ghi", "jkl"))</code> will return a virtual Collection that contains the four strings. This method concatenates Collections; similarly one can concatenate Iterables or Iterators. 

<b>Maps</b>

This class contains two groups of methods in this class: creational and functional. 

Creational methods build maps from materials that the user supplies: <code>Map&lt;X,Y> toMap(X key1, Y value1, X key2, Y key2)</code> and the like will create a map that contains just these two keys; you can pass an array with keys and values (odd elements are keys, even elements are values), and <code>toMap()</code> will create a Map based on this array. Another <code>toMap()</code> takes a vararg array of Map.Entry instances and creates a virtual Map based on this array. Neither of these methods cares to copy arrays; they are all just views.

There is a caveat regarding using these creational methods: it is your responsibility to guarantee that all keys are distinct; it is a contract of Map interface that keys in the map are all distinct, and can form a Set. None of the creational methods checks whether keys are distinct. Generally speaking, no existing implementation of Set or Map interface, except probably UnmodifiableMap and UnmodifiableCollection, can guarantee this distinction. When you add elements to a Set, they are all distinct - but what if you change the elements later? There are no observers to react to such changes.

The purpose of functional methods is to implement standard or almost standard operations on Maps. <code>Map&lt;X,Z> compose(Map&lt;X,Y>, Map&lt;Y,Z>)</code> returns a virtual Map which is the two Maps' composition. Four <code>map()</code> methods apply a Map to a List, a Collection, an Iterable and an Iterator respectively. <code>Map&lt;X,Y> restrict(Map&lt;X,Y>, Collection&lt;X>)</code> restricts a Map to a Collection.

The following functional methods do create Set or Map instances. So far there is no factory method that would return the right Map or Set instance; I just use LinkedHashMap and HashSet as an ultimate container choice. This area definitely need some development.

<code>Set&lt;X> resolve(Map&lt;X,Y> map, Y y)</code> returns a Set of X such that map.get(x).equals(y).
<code>Map&lt;Y,X> inverse(Map&lt;X,Y>)</code> returns a new map that is inverse to the original map; if none exists, an exception is thrown. Another method, <code>revert(Map&lt;X,Y>)</code> revert a Map even if it is not an one-to-one. It returns, for a <code>Map&lt;X,Y> f</code> it returns a <code>Map&lt;Y,Set&lt;X>> g</code> such that for each Y y in <code>g.keySet() the value of </code>g.get(y)</code> is a <code>Set&lt;Y></code> of all those <code>X x</code> that <code>f.get(x).equals(y)</code>.

<h2>Example of Usage</h2>

In the following sample program the files in the specified directory are grouped by their types, as defined in the provided list.

<pre class="sourcecode"><code>
<b>package</b> com.myjavatools.lib.foundation;

<b>import</b> java.io.*;
<b>import</b> java.util.*;

<b>public</b> <b>class</b> Sample1 {

  <b>public</b> <b>static</b> <b>void</b> main(String[] args) {
    String folderName = args.length &lt; 1 ? <font color="#9933CC">&quot;.&quot;</font> : args[0];

    Map&lt;String,String&gt; fileToType =
        Maps.toMap(<font color="#9933CC">&quot;gif&quot;</font>,  <font color="#9933CC">&quot;image&quot;</font>,
                   <font color="#9933CC">&quot;jpg&quot;</font>,  <font color="#9933CC">&quot;image&quot;</font>,
                   <font color="#9933CC">&quot;jpeg&quot;</font>, <font color="#9933CC">&quot;image&quot;</font>,
                   <font color="#9933CC">&quot;png&quot;</font>,  <font color="#9933CC">&quot;image&quot;</font>,
                   <font color="#9933CC">&quot;java&quot;</font>, <font color="#9933CC">&quot;source code&quot;</font>,
                   <font color="#9933CC">&quot;cpp&quot;</font>,  <font color="#9933CC">&quot;source code&quot;</font>,
                   <font color="#9933CC">&quot;hpp&quot;</font>,  <font color="#9933CC">&quot;source code&quot;</font>,
                   <font color="#9933CC">&quot;class&quot;</font>,<font color="#9933CC">&quot;binary&quot;</font>,
                   <font color="#9933CC">&quot;obj&quot;</font>,  <font color="#9933CC">&quot;binary&quot;</font>,
                   <font color="#9933CC">&quot;exe&quot;</font>,  <font color="#9933CC">&quot;binary&quot;</font>,
                   <font color="#9933CC">&quot;dll&quot;</font>,  <font color="#9933CC">&quot;library&quot;</font>,
                   <font color="#9933CC">&quot;lib&quot;</font>,  <font color="#9933CC">&quot;library&quot;</font>,
                   <font color="#9933CC">&quot;so&quot;</font>,   <font color="#9933CC">&quot;library&quot;</font>,
                   <font color="#9933CC">&quot;sl&quot;</font>,   <font color="#9933CC">&quot;library&quot;</font>);

    Function&lt;File,String&gt; extension = <b>new</b> Function&lt;File,String&gt;() {
      <b>public</b> String apply(File file) {
        String name = file.getName();
        <b>return</b> name.substring(name.lastIndexOf(<font color="#9933CC">'.'</font>) + 1);
      }
    };

    <font color="#003399"><i>// the function returns file type for a file</i></font>
    Function&lt;File,String&gt; fileType = Function.function(fileToType).compose(extension);

    <font color="#003399"><i>// the list of files in the folder</i></font>
    List&lt;File&gt; contents = Arrays.asList(<b>new</b> File(folderName).listFiles());

    <font color="#003399"><i>// the same files grouped by their file types</i></font>
    <font color="#003399"><i>// only during this operation a new container is created.</i></font>
    Map&lt;String, Set&lt;File&gt;&gt; filesGroupedByType =
        Maps.revert(fileType.toMap(contents));

    <b>for</b> (String type : filesGroupedByType.keySet()) {
      System.out.println(type + <font color="#9933CC">&quot;:&quot;</font>);
      <b>for</b> (File file : filesGroupedByType.get(type)) {
        System.out.println(<font color="#9933CC">&quot;  &quot;</font> + file);
      }
    }
  }
}
</code></pre>

<h2>Conclusion</h2>

Although these simple classes are very versatile, and very non-intrusive if used correctly, that is, in a natural and simple way, I have a feeling that this is only the beginning of a long way to switching from XIX century programming style - "matrices with indexes" to the more advanced "operator" style.

Here are the links: 
<a href="http://www.myjavatools.com/projects/v.5.0/lib/doc/index.html">documentation</a>, 
<a href="http://www.myjavatools.com/projects/v.5.0/lib/mjlib-src.jar">source code jar</a>,  
<a href="http://www.myjavatools.com/projects/v.5.0/lib/mjlib.jar">binary jar</a>, 
<a href="http://www.myjavatools.com/projects/v.5.0/lib/mjlib50.zip">the full archive: source, docs, tests, project file for JBuilder.</a> 

Everything is free, as in free thought. I am thankful to the great Borland's JBuilder team for creating the beautiful JBuilder 2005 that I've been using while developing this. Yes, I am a Borland employee - but this seems to be the first time I thank my colleagues.
<lj-cut>
